grammar PersonifyLanguage
  rule template
    (parts_including_tail)* {
      def eval(env={})
        elements.map{|e| e.eval(env) }.join("")
      end
    }
  end
  
  rule parts_including_tail
    part / tail_part
  end
  
  rule part
    text / substitutable
  end
  
  rule tail_part
    '[' part {
      def eval(env)
        "[" + part.eval(env)
      end
    }
  end

  rule substitutable
    '[' space expressions space ']' {
      def eval(env)
        last_eval = expressions.eval(env)
        if last_eval.nil?
          text_value
        else
          last_eval
        end
      end
    }
  end
  
  rule block
    'DO' space ']' block_content '[' space 'END' <Block>
  end
  
  rule block_content
    (part)* <Literal>
  end
  
  rule expressions
     expression alternatives:(space "|" space expression_or_string)* {
      def eval(env)
        last_value = nil
        expressions.detect do |exp|
          last_value = exp.eval(env)
        end
        last_value
      end
      
      def expressions
        [expression] + alternatives.elements.map {|elt| elt.expression_or_string}
      end
    }
  end
  
  rule expression
    function / key / string
  end
  
  rule expression_or_string
    expression / implicit_string
  end
  
  rule function
    key space "(" space parameters space ")" space block:(block)? <Function>
  end
      
  rule parameters 
    first_param:(expression_or_string)? more_expressions:(space "," space expression_or_string)* {
      def eval(env={})
        self.parameters.map{|param| param.eval(env) }
      end
      def parameters
        (self.first_param.respond_to?(:eval) ? [first_param] : []) + more_expressions.elements.map {|elt| elt.expression_or_string}
      end
    }
  end
  
  rule key
    !reserved ([A-Z0-9] [A-Z0-9._]*) {      
      def eval(env)
        keys = self.to_s.split(".")
        keys.inject(env){|acc,k| acc && acc[k] }
      end
            
      def name
        text_value
      end
      
      def to_s
        self.name.downcase.to_s
      end
    }
  end
  
  rule reserved
   "END" / "DO"
  end
  
  rule string
    '"' string_value '"' {
      def eval(env={})
        string_value.eval(env)
      end
    }
  end
  
  rule implicit_string
    [^|\],)]+ <Literal>
  end
  
  rule string_value
    [^"]* <Literal>
  end
  
  rule text
    [^\[] [^\[]* <Literal>
  end
  
  rule space
    [ \n]*
  end
end